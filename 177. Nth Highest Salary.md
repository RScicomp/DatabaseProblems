# Finding the Nth Highest Salary in SQL

This document compares two different SQL approaches for finding the nth highest salary from a table.

## Time Complexity Analysis

### OFFSET Approach
- **Overall Complexity**: O(n)
- **Breakdown**:
  - Table scan: O(n)
  - DISTINCT operation: O(n)
  - OFFSET operation: O(N) where N is the offset value
- **Why it matters**:
  - Linear scanning makes it efficient for single-pass operations
  - Performance primarily depends on table size
  - Memory usage is minimal as it only needs to track distinct values

### DENSE_RANK Approach
- **Overall Complexity**: O(m log m) where m is the number of distinct salaries
- **Breakdown**:
  - Window function sorting: O(m log m)
  - Rank computation: O(m)
  - Final filtering: O(1)
- **Why it matters**:
  - Sorting overhead for distinct values can be significant
  - More expensive when there are many unique salaries
  - Additional memory needed for sorting and rank computation


### Performance Impact Examples
- For a table with many duplicate salaries:
  - OFFSET approach: Linear scan regardless of duplicates
  - DENSE_RANK approach: Better performance as m (distinct values) << n (total rows)
- For a table with mostly unique salaries:
  - OFFSET approach: Maintains linear performance
  - DENSE_RANK approach: Performance closer to O(n log n) as m approaches n

### Approach 1: Using OFFSET

```sql
CREATE OR REPLACE FUNCTION NthHighestSalary(N INT) RETURNS TABLE (Salary INT) AS $$
BEGIN
    -- Input validation
    IF n < 1 THEN
        RETURN NULL;  -- Return null if n is invalid
    END IF;

    RETURN QUERY (
        SELECT DISTINCT e.salary
        FROM Employee e
        ORDER BY e.salary DESC
        LIMIT 1 OFFSET n - 1
    );
END;
$$ LANGUAGE plpgsql;
```

### Approach 2: Using DENSE_RANK

```sql
CREATE OR REPLACE FUNCTION NthHighestSalary(N INT) RETURNS TABLE (Salary INT) AS $$
BEGIN
    RETURN QUERY (
        SELECT a.salary
        FROM (
            SELECT e.salary, 
                   DENSE_RANK() OVER (ORDER BY e.salary DESC) r 
            FROM Employee e
        ) a
        WHERE a.r = n
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql;
```

### Important Considerations

1. **Function Syntax**
   - Uses PostgreSQL's specific `RETURNS TABLE` syntax
   - Requires `LANGUAGE plpgsql` specification
   - Uses `$$` for function body delimiter
   - Uses `RETURN QUERY` for returning result sets

2. **OFFSET vs DENSE_RANK Approach**
   - OFFSET approach:
     - Simpler to understand
     - Requires DISTINCT to handle duplicates
     - May be slower for large offsets
   - DENSE_RANK approach:
     - Handles duplicates naturally
     - More efficient for larger N values
     - Consistent with SQL standard window functions

3. **NULL Handling**
   - Input validation important for OFFSET approach
   - DENSE_RANK approach naturally returns empty result for invalid N
   - Both return empty result set when no matching salary exists

4. **Performance Considerations**
   - DENSE_RANK:
     - Single table scan
     - Memory overhead for window function
   - OFFSET:
     - Multiple scans for DISTINCT
     - May need to scan N rows for large offsets

## Recommendation

- Use Approach 1 (OFFSET) for:
  - Small to medium-sized datasets
  - When code readability is a priority
  - When the data is already sorted or indexed

- Use Approach 2 (Subquery) for:
  - When you have good indexes on the Salary column
  - When you need to find salaries close to the top (small N)
  - When avoiding sorting operations is beneficial

## Note on NULL Values
Both approaches need to consider NULL handling in real-world applications. It's recommended to add NULL checks or use COALESCE when dealing with salary data that might contain NULL values. 
